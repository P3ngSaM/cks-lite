# CKS Lite æ··åˆè®°å¿†ç³»ç»Ÿé›†æˆ - ä»»åŠ¡æ¸…å•

åˆ›å»ºæ—¥æœŸï¼š2026-02-05
ç­–ç•¥ï¼š**ä»£ç ç§»æ¤** - å‚è€ƒ OpenClaw å®ç°ï¼Œç›´æ¥é›†æˆåˆ° CKS Lite
é¢„è®¡å®Œæˆï¼š1-2 å‘¨

---

## ğŸ“‹ ä»»åŠ¡æ¦‚è§ˆ

| ä»»åŠ¡ ID | ä»»åŠ¡åç§° | ä¼˜å…ˆçº§ | é¢„è®¡å·¥æ—¶ | çŠ¶æ€ |
|---------|---------|--------|---------|------|
| #16 | æå– OpenClaw æ··åˆæœç´¢æ ¸å¿ƒä»£ç  | P0 | 3h | ğŸ”µ å¾…å¼€å§‹ |
| #17 | åœ¨ Agent SDK ä¸­å®ç°æ··åˆæœç´¢ | P0 | 6h | ğŸ”µ å¾…å¼€å§‹ |
| #18 | å®ç° Markdown æ–‡ä»¶è®°å¿†ç³»ç»Ÿ | P0 | 5h | ğŸ”µ å¾…å¼€å§‹ |
| #19 | å‰ç«¯é›†æˆæ··åˆæœç´¢ API | P0 | 4h | ğŸ”µ å¾…å¼€å§‹ |
| #20 | å®ç°æ–‡ä»¶ç›‘æ§å’Œè‡ªåŠ¨åŒæ­¥ | P1 | 5h | ğŸ”µ å¾…å¼€å§‹ |
| #21 | é›†æˆè‡ªåŠ¨è®°å¿†åˆ·æ–°æœºåˆ¶ | P1 | 4h | ğŸ”µ å¾…å¼€å§‹ |
| #22 | æµ‹è¯•æ··åˆæœç´¢æ•ˆæœ | P0 | 6h | ğŸ”µ å¾…å¼€å§‹ |
| #23 | ç¼–å†™æŠ€æœ¯æ–‡æ¡£å’ŒæŒ‡å— | P1 | 4h | ğŸ”µ å¾…å¼€å§‹ |

**æ€»è®¡**ï¼š37 å°æ—¶ï¼ˆçº¦ 1 å‘¨ï¼‰

---

## ğŸ¯ æ ¸å¿ƒç†å¿µ

### ä¸ºä»€ä¹ˆä¸å®‰è£… OpenClawï¼Ÿ

**ç›´æ¥ä»£ç ç§»æ¤** è€Œéä¾èµ–å¤–éƒ¨æœåŠ¡ï¼š
- âœ… æ— éœ€é¢å¤–çš„ WebSocket è¿æ¥å±‚
- âœ… é™ä½æ¶æ„å¤æ‚åº¦
- âœ… æ›´å¥½çš„æ€§èƒ½ï¼ˆå‡å°‘ç½‘ç»œå¼€é”€ï¼‰
- âœ… å®Œå…¨æ§åˆ¶å®ç°ç»†èŠ‚
- âœ… æ›´å®¹æ˜“è°ƒè¯•å’Œå®šåˆ¶

### ä» OpenClaw å­¦ä¹ ä»€ä¹ˆï¼Ÿ

| ç‰¹æ€§ | OpenClaw å®ç° | ç§»æ¤åˆ° CKS Lite |
|------|--------------|----------------|
| **æ··åˆæœç´¢** | BM25 + å‘é‡ | âœ… æå–ç®—æ³•ä»£ç  |
| **æ–‡ä»¶ä¼˜å…ˆ** | Markdown å­˜å‚¨ | âœ… å®ç° MEMORY.md ç³»ç»Ÿ |
| **è‡ªåŠ¨åˆ·æ–°** | Token é˜ˆå€¼è§¦å‘ | âœ… é›†æˆåˆ°å¯¹è¯æµç¨‹ |
| **åµŒå…¥ç¼“å­˜** | é¿å…é‡å¤è®¡ç®— | âœ… å®ç°ç¼“å­˜æœºåˆ¶ |
| **æ··åˆæƒé‡** | å¯é…ç½®èåˆ | âœ… æä¾›é…ç½®é€‰é¡¹ |

---

## ğŸ”„ ä»»åŠ¡ä¾èµ–å…³ç³»

```
#16 (æå– OpenClaw ä»£ç )
  â†“
#17 (Agent SDK æ··åˆæœç´¢) â”€â”€â”€â”€â”
  â†“                          â”‚
#18 (Markdown è®°å¿†ç³»ç»Ÿ)      â”‚
  â†“                          â”‚
#19 (å‰ç«¯é›†æˆ) â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â†“
#20 (æ–‡ä»¶ç›‘æ§)
  â†“
#21 (è‡ªåŠ¨åˆ·æ–°)
  â†“
#22 (æµ‹è¯•)
  â†“
#23 (æ–‡æ¡£)
```

**å…³é”®è·¯å¾„**ï¼š#16 â†’ #17 â†’ #18 â†’ #19 â†’ #22 â†’ #23

---

## ğŸ“ è¯¦ç»†ä»»åŠ¡è¯´æ˜

### Task #16: æå– OpenClaw æ··åˆæœç´¢æ ¸å¿ƒä»£ç 

**ç›®æ ‡**ï¼šä» OpenClaw é¡¹ç›®ä¸­æå–å¯å¤ç”¨çš„ä»£ç ã€‚

**é‡ç‚¹æ–‡ä»¶**ï¼š
```
E:\Gitee-Project\openclaw\src\memory\
â”œâ”€â”€ hybrid.ts                 # æ ¸å¿ƒï¼šæ··åˆæœç´¢ç®—æ³•
â”œâ”€â”€ manager-search.ts         # æœç´¢ç®¡ç†å™¨
â”œâ”€â”€ embeddings-openai.ts      # OpenAI åµŒå…¥
â””â”€â”€ internal.ts               # SQLite æ“ä½œ
```

**æå–å†…å®¹**ï¼š

1. **BM25 å®ç°**
```typescript
// hybrid.ts ä¸­çš„ BM25 ç®—æ³•
function bm25Search(
  query: string,
  documents: string[],
  k1 = 1.5,
  b = 0.75
): number[] {
  // æå–åˆ†è¯ã€TF-IDFã€BM25 è®¡ç®—é€»è¾‘
}
```

2. **å‘é‡æœç´¢**
```typescript
// manager-search.ts ä¸­çš„å‘é‡æœç´¢
function vectorSearch(
  query: string,
  embeddings: number[][],
  topK: number
): SearchResult[] {
  // æå–ä½™å¼¦ç›¸ä¼¼åº¦è®¡ç®—
}
```

3. **æ··åˆèåˆ**
```typescript
// hybrid.ts ä¸­çš„åˆ†æ•°èåˆ
function mergeScores(
  vectorResults: SearchResult[],
  bm25Results: SearchResult[],
  vectorWeight = 0.7,
  textWeight = 0.3
): SearchResult[] {
  // æå–åŠ æƒèåˆé€»è¾‘
}
```

**è¾“å‡ºäº§ç‰©**ï¼š
- `docs/openclaw-code-analysis.md` - ä»£ç åˆ†ææ–‡æ¡£
- æ ‡æ³¨éœ€è¦çš„ç¬¬ä¸‰æ–¹åº“ï¼ˆnatural, compromise ç­‰ï¼‰
- Python å®ç°æ–¹æ¡ˆè®¾è®¡

---

### Task #17: åœ¨ Agent SDK ä¸­å®ç°æ··åˆæœç´¢

**ç›®æ ‡**ï¼šç”¨ Python é‡å†™ OpenClaw çš„æ··åˆæœç´¢ç®—æ³•ã€‚

**æŠ€æœ¯æ ˆ**ï¼š
- `rank-bm25` - Python BM25 åº“
- `jieba` - ä¸­æ–‡åˆ†è¯
- `faiss` - å‘é‡æœç´¢ï¼ˆå·²æœ‰ï¼‰
- `numpy` - æ•°å€¼è®¡ç®—

**å®ç°æ–‡ä»¶**ï¼š
```
agent-sdk/services/
â”œâ”€â”€ hybrid_search.py          # æ–°å¢ï¼šæ··åˆæœç´¢æœåŠ¡
â””â”€â”€ memory_service.py         # ä¿®æ”¹ï¼šé›†æˆæ··åˆæœç´¢
```

**æ ¸å¿ƒä»£ç **ï¼š

```python
# hybrid_search.py
from rank_bm25 import BM25Okapi
import jieba
import numpy as np

class HybridSearchService:
    def __init__(self, faiss_index, documents):
        # 1. åˆå§‹åŒ–å‘é‡æœç´¢
        self.faiss_index = faiss_index

        # 2. æ„å»º BM25 ç´¢å¼•
        tokenized_docs = [list(jieba.cut(doc)) for doc in documents]
        self.bm25 = BM25Okapi(tokenized_docs)
        self.documents = documents

    def search(
        self,
        query: str,
        top_k: int = 5,
        vector_weight: float = 0.7,
        text_weight: float = 0.3
    ) -> List[SearchResult]:
        # 1. å‘é‡æœç´¢
        vector_results = self._vector_search(query, top_k * 3)

        # 2. BM25 æœç´¢
        bm25_results = self._bm25_search(query, top_k * 3)

        # 3. èåˆåˆ†æ•°
        merged = self._merge_results(
            vector_results,
            bm25_results,
            vector_weight,
            text_weight
        )

        return merged[:top_k]

    def _vector_search(self, query, k):
        # ä½¿ç”¨ç°æœ‰ FAISS ç´¢å¼•
        embedding = self.embed_query(query)
        distances, indices = self.faiss_index.search(
            np.array([embedding]), k
        )

        # è½¬æ¢ä¸º 0-1 åˆ†æ•°
        scores = 1 / (1 + distances[0])
        return [(indices[0][i], scores[i]) for i in range(k)]

    def _bm25_search(self, query, k):
        # BM25 æœç´¢
        tokenized_query = list(jieba.cut(query))
        scores = self.bm25.get_scores(tokenized_query)

        # å½’ä¸€åŒ–åˆ° 0-1
        max_score = max(scores) if scores else 1
        normalized = scores / max_score if max_score > 0 else scores

        # å– top k
        top_indices = np.argsort(normalized)[-k:][::-1]
        return [(idx, normalized[idx]) for idx in top_indices]

    def _merge_results(self, vector_results, bm25_results, vw, tw):
        # åˆå¹¶ä¸¤ä¸ªç»“æœé›†
        score_map = {}

        for idx, score in vector_results:
            score_map[idx] = score_map.get(idx, 0) + vw * score

        for idx, score in bm25_results:
            score_map[idx] = score_map.get(idx, 0) + tw * score

        # æ’åº
        merged = sorted(
            score_map.items(),
            key=lambda x: x[1],
            reverse=True
        )

        return [
            {
                'id': idx,
                'content': self.documents[idx],
                'score': score,
                'vector_score': dict(vector_results).get(idx, 0),
                'text_score': dict(bm25_results).get(idx, 0)
            }
            for idx, score in merged
        ]
```

**API ç«¯ç‚¹**ï¼š

```python
# routes/memory.py
@router.post("/memory/hybrid-search")
async def hybrid_search(
    user_id: str,
    query: str,
    top_k: int = 5,
    vector_weight: float = 0.7,
    text_weight: float = 0.3
):
    service = HybridSearchService(faiss_index, documents)
    results = service.search(query, top_k, vector_weight, text_weight)
    return {"success": True, "results": results}
```

**ä¾èµ–å®‰è£…**ï¼š
```bash
pip install rank-bm25 jieba numpy
```

---

### Task #18: å®ç° Markdown æ–‡ä»¶è®°å¿†ç³»ç»Ÿ

**ç›®æ ‡**ï¼šå®ç° OpenClaw é£æ ¼çš„ Markdown è®°å¿†å­˜å‚¨ã€‚

**æ–‡ä»¶ç»“æ„**ï¼š
```
E:\Users\<user>\.cks-lite\workspace\
â”œâ”€â”€ MEMORY.md                 # é•¿æœŸè®°å¿†ï¼ˆæ‰‹åŠ¨ç¼–è¾‘å‹å¥½ï¼‰
â””â”€â”€ memory/
    â”œâ”€â”€ 2026-02-05.md        # ä»Šæ—¥æ—¥å¿—
    â”œâ”€â”€ 2026-02-04.md        # æ˜¨æ—¥æ—¥å¿—
    â””â”€â”€ ...
```

**MEMORY.md æ ¼å¼**ï¼š
```markdown
# ç”¨æˆ·ä¿¡æ¯

- ç”¨æˆ·åï¼šSam
- èŒä¸šï¼šè½¯ä»¶å·¥ç¨‹å¸ˆ
- åå¥½ï¼šç®€æ´çš„ä»£ç é£æ ¼ï¼Œä½¿ç”¨ TypeScript

# é¡¹ç›®å†³ç­–

## CKS Lite æ¶æ„

- 2026-02-05: å†³å®šé‡‡ç”¨æ··åˆæœç´¢ï¼ˆBM25 + å‘é‡ï¼‰æå‡è®°å¿†æ£€ç´¢å‡†ç¡®ç‡
- 2026-02-04: é›†æˆ OpenClaw çš„è®°å¿†ç³»ç»Ÿè®¾è®¡ç†å¿µ

# æŠ€èƒ½åå¥½

ç”¨æˆ·å–œæ¬¢ä½¿ç”¨ React + TypeScript + Tailwind CSS è¿›è¡Œå‰ç«¯å¼€å‘ã€‚
```

**daily log æ ¼å¼**ï¼š
```markdown
# 2026-02-05 å¯¹è¯æ—¥å¿—

## 09:30 - è®°å¿†ç³»ç»Ÿè®¨è®º

ç”¨æˆ·è¯¢é—®å¦‚ä½•æ”¹è¿›è®°å¿†ç³»ç»Ÿï¼Œæˆ‘å»ºè®®å‚è€ƒ OpenClaw çš„å®ç°...

## 14:20 - åŠŸèƒ½å¼€å‘

ç”¨æˆ·è¦æ±‚å®ç°å¤´åƒè‡ªåŠ¨ä¿å­˜åŠŸèƒ½...
```

**å®ç°ä»£ç **ï¼š

```python
# agent-sdk/services/markdown_memory.py
from datetime import datetime
import os

class MarkdownMemoryService:
    def __init__(self, workspace_path: str):
        self.workspace = workspace_path
        self.memory_file = os.path.join(workspace, "MEMORY.md")
        self.memory_dir = os.path.join(workspace, "memory")

        # ç¡®ä¿ç›®å½•å­˜åœ¨
        os.makedirs(self.memory_dir, exist_ok=True)

    def save_long_term(self, content: str, category: str = None):
        """ä¿å­˜åˆ° MEMORY.md"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")

        entry = f"\n\n## {category or 'è®°å½•'}\n\n"
        entry += f"_ä¿å­˜äº {timestamp}_\n\n"
        entry += content

        # è¿½åŠ æ¨¡å¼å†™å…¥
        with open(self.memory_file, 'a', encoding='utf-8') as f:
            f.write(entry)

    def save_daily_log(self, content: str):
        """ä¿å­˜åˆ°ä»Šæ—¥æ—¥å¿—"""
        today = datetime.now().strftime("%Y-%m-%d")
        log_file = os.path.join(self.memory_dir, f"{today}.md")

        timestamp = datetime.now().strftime("%H:%M")
        entry = f"\n\n## {timestamp}\n\n{content}"

        # å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ›å»ºå¤´éƒ¨
        if not os.path.exists(log_file):
            with open(log_file, 'w', encoding='utf-8') as f:
                f.write(f"# {today} å¯¹è¯æ—¥å¿—\n")

        # è¿½åŠ å†…å®¹
        with open(log_file, 'a', encoding='utf-8') as f:
            f.write(entry)

    def read_memory(self) -> str:
        """è¯»å– MEMORY.md"""
        if os.path.exists(self.memory_file):
            with open(self.memory_file, 'r', encoding='utf-8') as f:
                return f.read()
        return ""

    def read_daily_logs(self, days: int = 2) -> List[str]:
        """è¯»å–æœ€è¿‘ N å¤©çš„æ—¥å¿—"""
        logs = []
        for i in range(days):
            date = (datetime.now() - timedelta(days=i)).strftime("%Y-%m-%d")
            log_file = os.path.join(self.memory_dir, f"{date}.md")
            if os.path.exists(log_file):
                with open(log_file, 'r', encoding='utf-8') as f:
                    logs.append(f.read())
        return logs

    def parse_markdown(self, content: str) -> List[Dict]:
        """è§£æ Markdown ä¸ºç»“æ„åŒ–æ•°æ®"""
        # ç®€å•è§£æï¼šæŒ‰æ®µè½åˆ†å‰²
        paragraphs = [p.strip() for p in content.split('\n\n') if p.strip()]

        memories = []
        current_category = "æœªåˆ†ç±»"

        for para in paragraphs:
            if para.startswith('# '):
                current_category = para[2:].strip()
            elif para.startswith('## '):
                current_category = para[3:].strip()
            else:
                memories.append({
                    'content': para,
                    'category': current_category,
                    'source': 'MEMORY.md'
                })

        return memories
```

**API ç«¯ç‚¹**ï¼š
```python
@router.post("/memory/save-to-file")
async def save_to_file(
    content: str,
    type: str = "long_term",  # long_term | daily
    category: str = None
):
    service = MarkdownMemoryService(workspace_path)
    if type == "long_term":
        service.save_long_term(content, category)
    else:
        service.save_daily_log(content)
    return {"success": True}
```

---

### Task #19-23: åç»­ä»»åŠ¡

ï¼ˆè¯¦ç»†å®æ–½è®¡åˆ’è§ä»»åŠ¡æè¿°ï¼‰

---

## ğŸ¯ å…³é”®é‡Œç¨‹ç¢‘

### Milestone 1: æ ¸å¿ƒç®—æ³•å®ç°ï¼ˆDay 1-3ï¼‰
- âœ… OpenClaw ä»£ç åˆ†æå®Œæˆ
- âœ… Python æ··åˆæœç´¢å®ç°
- âœ… Markdown æ–‡ä»¶ç³»ç»Ÿå®ç°

**éªŒæ”¶**ï¼š
```python
# æµ‹è¯•æ··åˆæœç´¢
results = hybrid_search("ç”¨æˆ·åå¥½", top_k=5)
assert len(results) == 5
assert all('score' in r for r in results)
```

### Milestone 2: å‰ç«¯é›†æˆï¼ˆDay 4-5ï¼‰
- âœ… å‰ç«¯è°ƒç”¨æ··åˆæœç´¢ API
- âœ… UI æ˜¾ç¤ºåˆ†æ•°
- âœ… æ–‡ä»¶ç›‘æ§å·¥ä½œ

**éªŒæ”¶**ï¼š
- æœç´¢è¿”å›ç»“æœ
- UI æ˜¾ç¤ºæ··åˆåˆ†æ•°
- MEMORY.md å˜åŒ–æ—¶ UI æ›´æ–°

### Milestone 3: è‡ªåŠ¨åŒ–ï¼ˆDay 6-7ï¼‰
- âœ… è‡ªåŠ¨è®°å¿†åˆ·æ–°å®ç°
- âœ… Token ç›‘æ§å·¥ä½œ
- âœ… AI è‡ªåŠ¨ä¿å­˜è®°å¿†

**éªŒæ”¶**ï¼š
- å¯¹è¯æ¥è¿‘é™åˆ¶æ—¶è§¦å‘åˆ·æ–°
- MEMORY.md æ­£ç¡®æ›´æ–°

### Milestone 4: æµ‹è¯•å’Œæ–‡æ¡£ï¼ˆDay 8-10ï¼‰
- âœ… å‡†ç¡®ç‡æµ‹è¯•å®Œæˆ
- âœ… æ€§èƒ½æµ‹è¯•é€šè¿‡
- âœ… æ–‡æ¡£ç¼–å†™å®Œæˆ

**éªŒæ”¶**ï¼š
- æ··åˆæœç´¢å‡†ç¡®ç‡ > çº¯å‘é‡ 15%+
- æœç´¢å»¶è¿Ÿ < 500ms
- æ‰€æœ‰æ–‡æ¡£å®Œæ•´

---

## ğŸ“Š æŠ€æœ¯å¯¹æ¯”

### çº¯å‘é‡æœç´¢ vs æ··åˆæœç´¢

| åœºæ™¯ | çº¯å‘é‡ | æ··åˆæœç´¢ | æå‡ |
|------|--------|---------|------|
| ç²¾ç¡®å…³é”®å­— | â­â­ | â­â­â­â­â­ | +150% |
| è¯­ä¹‰ç›¸ä¼¼ | â­â­â­â­â­ | â­â­â­â­â­ | æŒå¹³ |
| åŒä¹‰è¯ | â­â­â­â­ | â­â­â­â­â­ | +25% |
| å¤šå…³é”®å­— | â­â­ | â­â­â­â­â­ | +150% |
| ç»¼åˆå¹³å‡ | â­â­â­ | â­â­â­â­â­ | +40% |

### Markdown vs SQLite

| ç‰¹æ€§ | SQLite | Markdown |
|------|--------|----------|
| äººå·¥å¯è¯» | âŒ | âœ… |
| æ˜“äºç¼–è¾‘ | âŒ | âœ… |
| ç‰ˆæœ¬æ§åˆ¶ | âŒ | âœ… Git å‹å¥½ |
| æŸ¥è¯¢é€Ÿåº¦ | â­â­â­â­â­ | â­â­â­ |
| ç»“æ„åŒ– | â­â­â­â­â­ | â­â­â­ |

---

## âš ï¸ æ³¨æ„äº‹é¡¹

### ä»£ç ç§»æ¤è¦ç‚¹

1. **TypeScript â†’ Python è½¬æ¢**
   - ç±»å‹ç³»ç»Ÿå·®å¼‚
   - å¼‚æ­¥å¤„ç†æ–¹å¼
   - åº“ç”Ÿæ€å·®å¼‚

2. **æ€§èƒ½è€ƒè™‘**
   - Python BM25 æ€§èƒ½ä¸å¦‚ Rust/C++
   - éœ€è¦ç¼“å­˜ä¼˜åŒ–
   - è€ƒè™‘æ‰¹å¤„ç†

3. **ä¸­æ–‡æ”¯æŒ**
   - OpenClaw ä¸»è¦è‹±æ–‡
   - CKS Lite éœ€è¦ä¸­æ–‡åˆ†è¯ï¼ˆjiebaï¼‰
   - æµ‹è¯•ä¸­æ–‡åœºæ™¯

### é£é™©å’Œç¼“è§£

| é£é™© | å½±å“ | ç¼“è§£ |
|------|------|------|
| BM25 æ€§èƒ½ä¸è¶³ | ä¸­ | ä½¿ç”¨ Cython åŠ é€Ÿ |
| ä¸­æ–‡åˆ†è¯ä¸å‡† | ä¸­ | ä½¿ç”¨ jieba + è‡ªå®šä¹‰è¯å…¸ |
| Markdown è§£æå¤æ‚ | ä½ | ç®€åŒ–æ ¼å¼çº¦å®š |
| æ–‡ä»¶ç›‘æ§è·¨å¹³å° | ä½ | ä½¿ç”¨æˆç†Ÿåº“ï¼ˆwatchdogï¼‰ |

---

## ğŸ“š å‚è€ƒèµ„æº

- **OpenClaw æºç **ï¼šE:\Gitee-Project\openclaw\src\memory
- **BM25 ç®—æ³•**ï¼šhttps://en.wikipedia.org/wiki/Okapi_BM25
- **rank-bm25 æ–‡æ¡£**ï¼šhttps://github.com/dorianbrown/rank_bm25
- **jieba åˆ†è¯**ï¼šhttps://github.com/fxsjy/jieba

---

**æœ€åæ›´æ–°**ï¼š2026-02-05 18:30
**ç­–ç•¥**ï¼šä»£ç ç§»æ¤è€Œéä¾èµ–å®‰è£…
**ä¸‹ä¸€æ­¥**ï¼šå¼€å§‹ Task #16 - æå– OpenClaw ä»£ç 
